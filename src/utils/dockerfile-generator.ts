/**
 * Dockerfile Generator
 * Auto-generates Dockerfiles based on detected runtime
 */

import type { DeployConfig } from "../types";

/**
 * Normalize start command for Docker deployment.
 * Adds --host flags for dev servers that default to localhost binding.
 */
function normalizeStartCommandForDocker(startCommand: string): string {
    const cmd = startCommand.trim();

    // Vite: needs --host flag
    // Matches: vite, vite dev, vite serve, npx vite, npm run dev (when it's vite)
    if (/\bvite\b/.test(cmd) && !cmd.includes("--host")) {
        return cmd + " --host";
    }

    // Next.js dev: needs -H 0.0.0.0
    // Matches: next dev, npx next dev
    if (/\bnext\s+dev\b/.test(cmd) && !cmd.includes("-H ") && !cmd.includes("--hostname")) {
        return cmd + " -H 0.0.0.0";
    }

    // Webpack Dev Server: needs --host 0.0.0.0
    if (/\bwebpack\s+serve\b/.test(cmd) && !cmd.includes("--host")) {
        return cmd + " --host 0.0.0.0";
    }

    // Angular CLI (ng serve): needs --host 0.0.0.0
    if (/\bng\s+serve\b/.test(cmd) && !cmd.includes("--host")) {
        return cmd + " --host 0.0.0.0";
    }

    // Nuxt dev: needs --host
    if (/\bnuxt\s+dev\b/.test(cmd) && !cmd.includes("--host") && !cmd.includes("-H")) {
        return cmd + " --host";
    }

    // Astro dev: needs --host
    if (/\bastro\s+dev\b/.test(cmd) && !cmd.includes("--host")) {
        return cmd + " --host";
    }

    // SvelteKit dev (vite-based, already covered by vite check above)

    return cmd;
}

/**
 * Default versions for each runtime (LTS or stable)
 */
const DEFAULT_VERSIONS: Record<string, string> = {
    node: "22", // Current LTS
    python: "3.12", // Latest stable
    go: "1.22", // Latest stable
    bun: "1", // Latest 1.x
    deno: "2", // Latest stable
};

/**
 * Parse runtime string which may include version (e.g., "node:20", "python:3.11")
 * Returns { runtime, version }
 */
function parseRuntime(runtimeSpec: string): { runtime: string; version: string } {
    const [runtime = "node", version] = runtimeSpec.toLowerCase().split(":");
    const defaultVersion = DEFAULT_VERSIONS[runtime] || "latest";
    return {
        runtime,
        version: version || defaultVersion,
    };
}

/**
 * Generate a Dockerfile based on the deployment config
 */
export function generateDockerfile(config: DeployConfig): string {
    const runtimeSpec = config.runtime || "node";
    const { runtime, version } = parseRuntime(runtimeSpec);

    switch (runtime) {
        case "node":
            return generateNodeDockerfile(config, version);
        case "python":
            return generatePythonDockerfile(config, version);
        case "go":
            return generateGoDockerfile(config, version);
        case "bun":
            return generateBunDockerfile(config, version);
        case "deno":
            return generateDenoDockerfile(config, version);
        default:
            throw new Error(
                `Unsupported runtime: ${runtime}. Supported: node, python, go, bun, deno`
            );
    }
}

/**
 * Generate Dockerfile for Node.js applications
 */
function generateNodeDockerfile(config: DeployConfig, version: string): string {
    return `# Auto-generated by okastr8
FROM node:${version}-alpine

WORKDIR /app

# Install dependencies
COPY package*.json ./
RUN npm ci --production

# Copy application code
COPY . .

# Run build steps if any
${config.buildSteps.length > 0 ? `RUN ${config.buildSteps.join(" && ")}` : "# No build steps"}

# Expose port
EXPOSE ${config.port}

# Health check
HEALTHCHECK --interval=30s --timeout=5s --start-period=10s --retries=3 \\
  CMD wget --spider -q http://127.0.0.1:${config.port}/ || exit 1

# Start application
CMD ${JSON.stringify(normalizeStartCommandForDocker(config.startCommand).split(" "))}
`;
}

/**
 * Generate Dockerfile for Python applications
 */
function generatePythonDockerfile(config: DeployConfig, version: string): string {
    return `# Auto-generated by okastr8
FROM python:${version}-slim

WORKDIR /app

# Install dependencies
COPY requirements.txt ./
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Run build steps if any
${config.buildSteps.length > 0 ? `RUN ${config.buildSteps.join(" && ")}` : "# No build steps"}

# Expose port
EXPOSE ${config.port}

# Health check
HEALTHCHECK --interval=30s --timeout=5s --start-period=10s --retries=3 \\
  CMD curl -f http://127.0.0.1:${config.port}/ || exit 1

# Start application
CMD ${JSON.stringify(normalizeStartCommandForDocker(config.startCommand).split(" "))}
`;
}

/**
 * Generate Dockerfile for Go applications
 */
function generateGoDockerfile(config: DeployConfig, version: string): string {
    return `# Auto-generated by okastr8
# Build stage
FROM golang:${version}-alpine AS builder

WORKDIR /app

# Copy go mod files
COPY go.mod go.sum ./
RUN go mod download

# Copy source code
COPY . .

# Build the application
RUN go build -o main .

# Runtime stage
FROM alpine:latest

WORKDIR /app

# Install ca-certificates for HTTPS
RUN apk --no-cache add ca-certificates wget

# Copy binary from builder
COPY --from=builder /app/main .

# Expose port
EXPOSE ${config.port}

# Health check
HEALTHCHECK --interval=30s --timeout=5s --start-period=10s --retries=3 \\
  CMD wget --spider -q http://127.0.0.1:${config.port}/ || exit 1

# Start application
CMD ["./main"]
`;
}

/**
 * Generate Dockerfile for Bun applications
 */
function generateBunDockerfile(config: DeployConfig, version: string): string {
    // Bun versions in Docker usage usually follow oven/bun:X-alpine
    return `# Auto-generated by okastr8
FROM oven/bun:${version}-alpine

WORKDIR /app

# Install dependencies
COPY package.json bun.lockb ./
RUN bun install --production

# Copy application code
COPY . .

# Run build steps if any
${config.buildSteps.length > 0 ? `RUN ${config.buildSteps.join(" && ")}` : "# No build steps"}

# Expose port
EXPOSE ${config.port}

# Health check
HEALTHCHECK --interval=30s --timeout=5s --start-period=10s --retries=3 \\
  CMD wget --spider -q http://127.0.0.1:${config.port}/ || exit 1

# Start application
CMD ${JSON.stringify(normalizeStartCommandForDocker(config.startCommand).split(" "))}
`;
}

/**
 * Generate Dockerfile for Deno applications
 */
function generateDenoDockerfile(config: DeployConfig, version: string): string {
    // Deno images often use denoland/deno:alpine or specific versions like denoland/deno:1.40.0
    // If version is 'alpine', we pass it through, otherwise we might want denoland/deno:version
    // Since default is '2', we probably want denoland/deno:2
    // But existing code used denoland/deno:alpine.
    // Let's assume user passes 'alpine' or a version number.
    // If version is numeric (e.g. "2"), we append it.
    // However, denoland/deno image tags are usually just the version (e.g. 1.39.0) or 'alpine'.
    // 'alpine' tag is often the latest alpine build.
    // Let's stick to the pattern: denoland/deno:${version}
    return `# Auto-generated by okastr8
FROM denoland/deno:${version}

WORKDIR /app

# Cache dependencies
COPY deno.json deno.lock ./
RUN deno cache deno.json

# Copy application code
COPY . .

# Expose port
EXPOSE ${config.port}

# Health check
HEALTHCHECK --interval=30s --timeout=5s --start-period=10s --retries=3 \\
  CMD wget --spider -q http://127.0.0.1:${config.port}/ || exit 1

# Start application
CMD ${JSON.stringify(normalizeStartCommandForDocker(config.startCommand).split(" "))}
`;
}
